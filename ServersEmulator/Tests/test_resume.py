
# Generated by CodiumAI
from emulator_generator import GameServer
import emulator_generator
from flask import app


# Dependencies:
# pip install pytest-mock
import pytest

"""
Code Analysis

Objective:
The 'resume_emulator' function is responsible for resuming the emulator and generating server updates for the game servers. It checks if the emulator is already running and if the game_servers list is not empty, and then starts generating server updates and streaming them to the client.

Inputs:
- HTTP GET request with query parameter 'interval' (optional)

Flow:
1. Check if there is an active request context.
2. Check if the emulator is already running. If yes, return an error message.
3. Check if the game_servers list is not empty. If yes, continue. If no, return an error message.
4. Get the 'interval' query parameter from the request and update the emulator_generator.interval variable if it is valid.
5. Start generating server updates for each game server in the game_servers list.
6. Stream the server updates to the client using Server-Sent Events (SSE).

Outputs:
- HTTP response with SSE content type and server updates as the response body.
- Error message if there is no active request context, the emulator is already running, or the game_servers list is empty.

Additional aspects:
- The function uses the 'has_request_context' function from the Quart framework to check if there is an active request context.
- The function uses the 'stream_response' and 'generate_server_updates' functions from the emulator_generator module to generate and stream server updates.
- The function updates the emulator_generator.interval variable with the 'interval' query parameter value if it is valid.
- The function logs messages using the Python logging module.
"""

class TestResumeEmulator:

    @pytest.mark.asyncio
    # Tests that the emulator is resumed successfully with valid interval. 
    @pytest.mark.asyncio
    async def test_resume_emulator_happy_path(self, mocker):
        # Arrange
        mocker.patch.object(emulator_generator, 'game_servers', [GameServer(1, 1)])
        mocker.patch.object(emulator_generator, 'is_emulator_running', False)
        client = app.test_client()
        expected_response = b"data: {\"ServerId\": 1, \"CurrentPlayers\": 50, \"IsRunning\": true, \"CpuTemperature\": 50.0, \"CpuSpeed\": 2000.0, \"HighScore\": 100, \"AvgScore\": 50.0, \"MemoryUsage\": 50.0, \"TimeStamp\": \"2022-01-01 00:00:00\"}\n\n"

        # Act
        response = await client.get('/resume_emulator?interval=5000')

        # Assert
        assert response.status_code == 200
        assert response.content_type == 'text/event-stream'
        assert await response.get_data() == expected_response

    # Tests that an error message is returned when there is no active request context. 
    @pytest.mark.asyncio
    async def test_resume_emulator_no_active_request_context(self, mocker):
        # Arrange
        client = app.test_client()
        mocker.patch.object(emulator_generator, 'game_servers', [GameServer(1, 1)])
        mocker.patch.object(emulator_generator, 'is_emulator_running', False)

        # Act
        with pytest.raises(RuntimeError):
            await client.get('/resume_emulator')

    # Tests that an error message is returned when the emulator is already running. 
    @pytest.mark.asyncio
    async def test_resume_emulator_emulator_already_running(self, mocker):
        # Arrange
        client = app.test_client()
        mocker.patch.object(emulator_generator, 'game_servers', [GameServer(1, 1)])
        mocker.patch.object(emulator_generator, 'is_emulator_running', True)

        # Act
        response = await client.get('/resume_emulator')

        # Assert
        assert response.status_code == 400
        assert await response.get_data() == b'Emulator is already running'

    # Tests that an error message is returned when the game_servers list is empty. 
    @pytest.mark.asyncio
    async def test_resume_emulator_empty_game_servers_list(self, mocker):
        # Arrange
        client = app.test_client()
        mocker.patch.object(emulator_generator, 'game_servers', [])
        mocker.patch.object(emulator_generator, 'is_emulator_running', False)

        # Act
        response = await client.get('/resume_emulator')

        # Assert
        assert response.status_code == 400
        assert await response.get_data() == b"No game servers's found! please initialize the emulator first"

    # Tests that the default interval value is used when an invalid or zero interval value is provided in the request. 
    @pytest.mark.asyncio
    async def test_resume_emulator_invalid_interval_value(self, mocker):
        # Arrange
        mocker.patch.object(emulator_generator, 'game_servers', [GameServer(1, 1)])
        mocker.patch.object(emulator_generator, 'is_emulator_running', False)
        client = app.test_client()
        expected_response = b"data: {\"ServerId\": 1, \"CurrentPlayers\": 50, \"IsRunning\": true, \"CpuTemperature\": 50.0, \"CpuSpeed\": 2000.0, \"HighScore\": 100, \"AvgScore\": 50.0, \"MemoryUsage\": 50.0, \"TimeStamp\": \"2022-01-01 00:00:00\"}\n\n"

        # Act
        response = await client.get('/resume_emulator?interval=0')

        # Assert
        assert response.status_code == 200
        assert response.content_type == 'text/event-stream'
        assert await response.get_data() == expected_response

    # Tests that an error message is returned when no game servers are found. 
    @pytest.mark.asyncio
    async def test_resume_emulator_no_game_servers_found(self, mocker):
        # Arrange
        client = app.test_client()
        mocker.patch.object(emulator_generator, 'game_servers', [])
        mocker.patch.object(emulator_generator, 'is_emulator_running', False)

        # Act
        response = await client.get('/resume_emulator')

        # Assert
        assert response.status_code == 400
        assert await response.get_data() == b"No game servers's found! please initialize the emulator first"